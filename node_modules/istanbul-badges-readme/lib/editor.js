"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.editReadme = exports.writeNewReadme = exports.getNewReadme = exports.getCoverageBadge = exports.getCoverageColor = exports.getReadmeHashes = void 0;
const fs_1 = __importDefault(require("fs"));
const arguments_1 = require("./arguments");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
const logger_1 = require("./logger");
const { logInfo } = (0, logger_1.logger)();
/**
 * Gets the hashes from the readme file.
 * @param {string} readmeFile - The readme file to search for hashes.
 * @returns {Hashes[]} - An array of hashes found in the readme file.
 */
const getReadmeHashes = (readmeFile) => {
    logInfo('- Getting readme hashes...');
    const readmeHashes = constants_1.hashesConst.coverage.map((hash) => {
        if (readmeFile.includes(`![${hash.value}]`)) {
            return hash;
        }
        return false;
    });
    const filteredHashes = readmeHashes.filter(Boolean);
    return filteredHashes;
};
exports.getReadmeHashes = getReadmeHashes;
/**
 * Determines the color representation of code coverage based on coverage percentage.
 * Optionally uses a provided string to configure custom color thresholds.
 * @param {number} coverage - The code coverage percentage to evaluate.
 * @param {string | false} colorConfigString - A string to configure custom color thresholds, or false to use defaults.
 * @returns {Colors} - The color associated with the given code coverage percentage, based on either default or custom thresholds.
 */
const getCoverageColor = (coverage, colorConfigString) => {
    const colorThresholds = (0, helpers_1.parseColorConfig)(colorConfigString);
    // Adjusting to use dynamic color thresholds from colorConfigString if provided
    if (coverage < colorThresholds.red) {
        return 'red';
    }
    if (coverage < colorThresholds.yellow) {
        return 'yellow';
    }
    return 'brightgreen';
};
exports.getCoverageColor = getCoverageColor;
const getCoverageBadge = (coverageFile, hashKey) => {
    var _a;
    logInfo(`- Getting coverage badge url for ${hashKey}...`);
    try {
        const parsedCoverage = JSON.parse(coverageFile);
        if (!parsedCoverage.total || !parsedCoverage.total[hashKey]) {
            return false;
        }
        const coverage = parsedCoverage.total[hashKey].pct;
        const customColors = (0, arguments_1.getArgumentValue)('colors');
        const color = (0, exports.getCoverageColor)(coverage, customColors);
        const customLabel = (0, arguments_1.getArgumentValue)(`${hashKey}Label`);
        const customBadgeStyle = (0, arguments_1.getArgumentValue)('style');
        const customBadgeLogo = (0, arguments_1.getArgumentValue)('logo');
        const badgeAlt = customLabel ? encodeURI(customLabel) : hashKey;
        const badgeStyle = (_a = constants_1.badgeStyles[customBadgeStyle.toString()]) !== null && _a !== void 0 ? _a : constants_1.badgeStyles.default;
        return (0, constants_1.coverageUrlConst)(badgeAlt, coverage, color, badgeStyle, customBadgeLogo);
    }
    catch (_b) {
        return false;
    }
};
exports.getCoverageBadge = getCoverageBadge;
const getNewReadme = (readmeFile, coverageFile) => (readmeHashes) => {
    logInfo('- Getting new readme data...');
    let newReadmeFile = readmeFile;
    return new Promise((resolve, reject) => {
        readmeHashes.forEach((hash) => {
            const coverageBadge = (0, exports.getCoverageBadge)(coverageFile, hash.key);
            if (!coverageBadge) {
                reject('There has been an error getting new coverage badges');
            }
            const pattern = `![${hash.value}]`;
            const enpatterned = (value) => `${pattern}(${value})`;
            const startIndex = newReadmeFile.indexOf(pattern);
            const valueToChangeStart = newReadmeFile.slice(startIndex + pattern.length);
            const valueToChangeIndex = valueToChangeStart.indexOf(')');
            const valueToChangeFinal = valueToChangeStart.substring(1, valueToChangeIndex);
            const oldBadge = enpatterned(valueToChangeFinal);
            const newBadge = enpatterned(coverageBadge);
            if ((0, arguments_1.getArgumentValue)('ci') && oldBadge !== newBadge) {
                reject("The coverage badge has changed, which isn't allowed with the `ci` argument");
            }
            newReadmeFile = newReadmeFile.replace(oldBadge, newBadge);
        });
        resolve(newReadmeFile);
    });
};
exports.getNewReadme = getNewReadme;
const writeNewReadme = (readmePath) => (newReadmeData) => {
    logInfo('- Writing new readme data...');
    try {
        return fs_1.default.writeFileSync(readmePath, newReadmeData, 'utf8');
    }
    catch (_a) {
        return false;
    }
};
exports.writeNewReadme = writeNewReadme;
const editReadme = async () => {
    logInfo('Editor process started');
    const readmeFile = await (0, helpers_1.readFileAsync)((0, helpers_1.getReadmePath)(constants_1.readmePathConst), 'utf-8');
    const coverageFile = await (0, helpers_1.readFileAsync)((0, helpers_1.getCoveragePath)(constants_1.coveragePathConst), 'utf8');
    return Promise.resolve((0, exports.getReadmeHashes)(readmeFile))
        .then((0, exports.getNewReadme)(readmeFile, coverageFile))
        .then((0, exports.writeNewReadme)((0, helpers_1.getReadmePath)(constants_1.readmePathConst)))
        .then(() => logInfo('Editor process ended'));
};
exports.editReadme = editReadme;
//# sourceMappingURL=editor.js.map